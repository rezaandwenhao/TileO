namespace ca.mcgill.ecse223.tileo.model;

use ActionTileSM.ump;
use PlayerSM.ump;

class TileO {
  1 <@>- * Game games;
  1 -> 0..1 Game currentGame;
}

class Game {
  mode { DESIGN{} GAME{} GAME_WON{} GAME_ROLLDIEACTIONCARD{} GAME_CONNECTTILESACTIONCARD{} GAME_REMOVECONNECTIONACTIONCARD{} GAME_TELEPORTACTIONCARD{} GAME_LOSETURNACTIONCARD{} }
  1 <@>- 2..4 Player players;
  1 <@>- * Tile tiles;
  1 <@>- * Connection connections;
  1 <@>- 1 Deck deck;
  1 <@>- 1 Die die;
  1 -> 0..1 Player currentPlayer;
  1 -> 0..1 WinTile winTile;
  const Integer SpareConnectionPieces = 32;
  Integer currentConnectionPieces;
  const Integer NumberOfActionCards = 32;
}

class Player {
  color { RED{} BLUE{} GREEN{} YELLOW{} }
  1 -> 0..1 Tile startingTile;
  0..4 -> 0..1 Tile currentTile;
  unique Integer number;
  Integer turnsUntilActive = 0;
  	// ADDITIONAL ATTRIBUTES, ADDED BY BIJAN
	private List<Tile> finalTiles = new ArrayList<Tile>();
  	// Bijan Sadeghi
	// return list of all possible Tiles a player can move to with a given die
	// roll
	public List<Tile> getPossibleMoves(Tile currentTile, Tile previousTile, int rollNumber) {

		// BASE CASE (ONE TILE MOVE)
		if (rollNumber == 1) {
			for (Tile neighbor : currentTile.getNeighbors()) {
				if (neighbor != previousTile)
					finalTiles.add(neighbor);
			}
		}

		// RECURSIVE STEP
		else {
			for (Tile neighbor : currentTile.getNeighbors()) {
				if (neighbor != previousTile)
					getPossibleMoves(neighbor, currentTile, rollNumber - 1);
			}
		}

		return finalTiles;
	}

	// Bijan Sadeghi
	public void resetFinalTiles() {
		finalTiles.clear();
	}
}

class Tile {
  abstract;

  2 tiles -- 0..4 Connection connections;
  Integer x;
  Integer y;
  Boolean hasBeenVisited = false;
  private List<Tile> neighbors = new ArrayList<Tile>();// ADDED BY BIJAN, USED IN GETNEIGHBORS() METHOD
  
  //gets the neighboring tiles
	public List<Tile> getNeighbors(){ // IMPLEMENTED BY BIJAN
		
		List<Tile> neighbors = new ArrayList<Tile>();
		
		for(Connection connection : this.getConnections()){
			if(connection.getTile(0)!=this)
				neighbors.add(connection.getTile(0));
			else
				neighbors.add(connection.getTile(1));
		}
		
		return neighbors;
		
	}
  
}

class ActionTile {
  isA Tile;
  private Mode currentCardMode;
  public void land(){
	  Game currentGame = this.getGame();
	  Player currentPlayer = currentGame.getCurrentPlayer();
      currentPlayer.setCurrentTile(this);
      this.setHasBeenVisited(true);
      Deck deck = currentGame.getDeck();
      ActionCard currentCard = deck.getCurrentCard();
      currentCardMode = currentCard.getActionCardGameMode();
      currentGame.setMode(currentCardMode);
  }

  immutable Integer inactivityPeriod;
  Integer turnsUntilActive= 0;
}

class NormalTile {
  isA Tile;
  public void land(){
	  Game currentGame = this.getGame();
	  Player currentPlayer = currentGame.getCurrentPlayer();
	  currentPlayer.setCurrentTile(this);
    
    if (currentGame.indexOfPlayer(currentPlayer) != currentGame.numberOfPlayers()-1) {
		currentGame.setCurrentPlayer(currentGame.getPlayer(currentGame.indexOfPlayer(currentPlayer)+1));
		}
		else {
			currentGame.setCurrentPlayer(currentGame.getPlayer(0));
			}
    
    this.setHasBeenVisited(true);
    currentGame.setMode(Mode.GAME);
}
}

class WinTile {
  isA Tile;
  public void land(){
	  Game currentGame = this.getGame();
	  this.setHasBeenVisited(true);
	  currentGame.setMode(Mode.GAME_WON);
  }
}

class Connection {
}

class Deck {
  1 <@>- 0..32 ActionCard cards;
  1 -> 0..1 ActionCard currentCard;
    public void shuffle(){// IMPLEMENTED BY BIJAN
	  Collections.shuffle(cards);
  }
  
}

class ActionCard {
  abstract;
  public abstract Mode getActionCardGameMode();

  public abstract int type();

  immutable String instructions;
}

class RollDieActionCard {
  isA ActionCard;
 @Override
public int type() {
	return 0;
}

public Mode getActionCardGameMode(){
	 return Mode.GAME_ROLLDIEACTIONCARD;
}
}

class ConnectTilesActionCard {
  isA ActionCard;
    public void play(Tile tile1, Tile tile2) throws InvalidInputException{
	  Game game = TileOApplication.getCurrentGame();
	  try {
			Connection connection = new Connection(game);
			connection.addTile(tile1);
			connection.addTile(tile2);
		}
		catch (RuntimeException e) {
			throw new InvalidInputException(e.getMessage());
		}
			
	  
  }
  @Override
	public int type() {
	return 1;
	}

	public Mode getActionCardGameMode()
	{
  		return Mode.GAME_CONNECTTILESACTIONCARD; 
	}
}

class RemoveConnectionActionCard {
  isA ActionCard;
   public void play(Connection connection){ //Added by Bijan
	  connection.delete();
  }
  
@Override
public int type() {
	return 2;
}

public Mode getActionCardGameMode()
{
  return Mode.GAME_REMOVECONNECTIONACTIONCARD; 
}
}

class TeleportActionCard {
  isA ActionCard;
   public void play(Tile tile){
	  tile.land();
  }
  
  @Override
public int type() {
	// TODO Auto-generated method stub
	return 3;
}

public Mode getActionCardGameMode()
{
  return Mode.GAME_TELEPORTACTIONCARD;
}
}

class LoseTurnActionCard {
  isA ActionCard;
  @Override
public int type() {
	return 4;
}

public Mode getActionCardGameMode()
{
  return Mode.GAME_LOSETURNACTIONCARD; 
}
}

class Die {
  public int roll(){ // IMPLEMENTED BY BIJAN
	  Random rand = new Random();
	  int rollNumber = rand.nextInt(6)+1;
	  return rollNumber;
  }
}
